package wasmtime

import (
	"context"
	"encoding/binary"
	"fmt"
	"math/rand"
	"strings"
	"time"

	"github.com/pkg/errors"
	"github.com/tidwall/gjson"
	"golang.org/x/text/encoding/unicode"

	conflog "github.com/machinefi/w3bstream/pkg/depends/conf/log"
	"github.com/machinefi/w3bstream/pkg/depends/x/mapx"
	"github.com/machinefi/w3bstream/pkg/modules/job"
	"github.com/machinefi/w3bstream/pkg/types/wasm"
	"github.com/machinefi/w3bstream/pkg/types/wasm/sql_util"
)

type (
	Import func(module, name string, f interface{}) error

	ABILinker interface {
		LinkABI(Import) error
	}

	ExportFuncs struct {
		rt  *Runtime
		res *mapx.Map[uint32, []byte]
		evs *mapx.Map[uint32, []byte]
		env *wasm.Env
		kvs wasm.KVStore
		db  wasm.SQLStore
		log conflog.Logger
		cl  *wasm.ChainClient
		ctx context.Context
		mq  *wasm.MqttClient
	}
)

func NewExportFuncs(ctx context.Context, rt *Runtime) (*ExportFuncs, error) {
	ef := &ExportFuncs{
		res: wasm.MustRuntimeResourceFromContext(ctx),
		evs: wasm.MustRuntimeEventTypesFromContext(ctx),
		kvs: wasm.MustKVStoreFromContext(ctx),
		log: wasm.MustLoggerFromContext(ctx),
		ctx: ctx,
	}
	ef.cl, _ = wasm.ChainClientFromContext(ctx)
	ef.db, _ = wasm.SQLStoreFromContext(ctx)
	ef.env, _ = wasm.EnvFromContext(ctx)
	ef.mq, _ = wasm.MQTTClientFromContext(ctx)
	ef.rt = rt

	return ef, nil
}

var (
	_     wasm.ABI = (*ExportFuncs)(nil)
	_rand          = rand.New(rand.NewSource(time.Now().UnixNano()))
)

func (ef *ExportFuncs) LinkABI(impt Import) error {
	for name, ff := range map[string]interface{}{
		"abort":            ef.Abort,
		"trace":            ef.Trace,
		"seed":             ef.Seed,
		"ws_log":           ef.Log,
		"ws_get_data":      ef.GetData,
		"ws_set_data":      ef.SetData,
		"ws_get_db":        ef.GetDB,
		"ws_set_db":        ef.SetDB,
		"ws_send_tx":       ef.SendTX,
		"ws_call_contract": ef.CallContract,
		"ws_set_sql_db":    ef.SetSQLDB,
		"ws_get_sql_db":    ef.GetSQLDB,
		"ws_get_env":       ef.GetEnv,
		"ws_send_mqtt_msg": ef.SendMqttMsg,
	} {
		if err := impt("env", name, ff); err != nil {
			return err
		}
	}

	return nil
}

func (ef *ExportFuncs) Log(logLevel, ptr, size int32) int32 {
	buf, err := ef.rt.Read(ptr, size)
	if err != nil {
		ef.log.Error(err)
		job.Dispatch(ef.ctx, job.NewWasmLogTask(ef.ctx, conflog.ErrorLevel.String(), err.Error()))
		return wasm.ResultStatusCode_Failed
	}
	switch conflog.Level(logLevel) {
	case conflog.TraceLevel:
		ef.log.Trace(string(buf))
	case conflog.DebugLevel:
		ef.log.Debug(string(buf))
	case conflog.InfoLevel:
		ef.log.Info(string(buf))
	case conflog.WarnLevel:
		ef.log.Warn(errors.New(string(buf)))
	case conflog.ErrorLevel:
		ef.log.Error(errors.New(string(buf)))
	default:
		job.Dispatch(ef.ctx, job.NewWasmLogTask(ef.ctx, conflog.TraceLevel.String(), string(buf)))
		return int32(wasm.ResultStatusCode_OK)
	}
	job.Dispatch(ef.ctx, job.NewWasmLogTask(ef.ctx, conflog.Level(logLevel).String(), string(buf)))
	return int32(wasm.ResultStatusCode_OK)
}

// Abort is reserved for imported func env.abort() which is auto-generated by assemblyScript
func (ef *ExportFuncs) Abort(msgPtr int32, fileNamePtr int32, line int32, col int32) {
	msg, err := ef.readString(msgPtr)
	if err != nil {
		ef.log.Error(errors.Wrap(err, "fail to decode arguments in env.abort"))
		return
	}
	fileName, err := ef.readString(fileNamePtr)
	if err != nil {
		ef.log.Error(errors.Wrap(err, "fail to decode arguments in env.abort"))
		return
	}
	ef.log.Error(errors.Errorf("abort: %s at %s:%d:%d", msg, fileName, line, col))
}

func (ef *ExportFuncs) readString(ptr int32) (string, error) {
	if ptr < 4 {
		return "", errors.Errorf("the pointer address %d is invalid", ptr)
	}

	decoder := unicode.UTF16(unicode.LittleEndian, unicode.IgnoreBOM).NewDecoder()

	lenData, err := ef.rt.Read(ptr-4, 4) // sizeof(uint32) is 4
	if err != nil {
		return "", err
	}
	len := binary.LittleEndian.Uint32(lenData)
	data, err := ef.rt.Read(ptr, int32(len))
	if err != nil {
		return "", err
	}
	utf8bytes, err := decoder.Bytes(data)
	if err != nil {
		return "", err
	}
	return string(utf8bytes), nil
}

// Trace is reserved for imported func env.trace() which is auto-generated by assemblyScript
func (ef *ExportFuncs) Trace(msgPtr int32, _ int32, arr ...float64) {
	msg, err := ef.readString(msgPtr)
	if err != nil {
		ef.log.Error(errors.Wrap(err, "fail to decode arguments in env.abort"))
		return
	}

	str := strings.Trim(strings.Join(strings.Fields(fmt.Sprint(arr)), ", "), "[]")
	if len(str) > 0 {
		str = " " + str
	}
	ef.log.Info("trace: %s%s", msg, str)
}

// Seed is reserved for imported func env.seed() which is auto-generated by assemblyScript
func (ef *ExportFuncs) Seed() float64 {
	return _rand.Float64() * float64(time.Now().UnixNano())
}

func (ef *ExportFuncs) GetData(rid, vmAddrPtr, vmSizePtr int32) int32 {
	data, ok := ef.res.Load(uint32(rid))
	if !ok {
		return int32(wasm.ResultStatusCode_ResourceNotFound)
	}

	if err := ef.rt.Copy(data, vmAddrPtr, vmSizePtr); err != nil {
		ef.log.Error(err)
		return int32(wasm.ResultStatusCode_TransDataToVMFailed)
	}

	return int32(wasm.ResultStatusCode_OK)
}

// TODO SetData if rid not exist, should be assigned by wasm?
func (ef *ExportFuncs) SetData(rid, addr, size int32) int32 {
	buf, err := ef.rt.Read(addr, size)
	if err != nil {
		ef.log.Error(err)
		return int32(wasm.ResultStatusCode_TransDataToVMFailed)
	}
	ef.res.Store(uint32(rid), buf)
	return int32(wasm.ResultStatusCode_OK)
}

func (ef *ExportFuncs) GetDB(kAddr, kSize int32, vmAddrPtr, vmSizePtr int32) int32 {
	key, err := ef.rt.Read(kAddr, kSize)
	if err != nil {
		ef.log.Error(err)
		return int32(wasm.ResultStatusCode_ResourceNotFound)
	}

	val, exist := ef.kvs.Get(string(key))
	if exist != nil || val == nil {
		return int32(wasm.ResultStatusCode_ResourceNotFound)
	}

	ef.log.WithValues("key", string(key), "val", string(val)).Info("host.GetDB")

	if err := ef.rt.Copy(val, vmAddrPtr, vmSizePtr); err != nil {
		ef.log.Error(err)
		return int32(wasm.ResultStatusCode_TransDataToVMFailed)
	}

	return int32(wasm.ResultStatusCode_OK)
}

func (ef *ExportFuncs) SetDB(kAddr, kSize, vAddr, vSize int32) int32 {
	key, err := ef.rt.Read(kAddr, kSize)
	if err != nil {
		ef.log.Error(err)
		return int32(wasm.ResultStatusCode_ResourceNotFound)
	}
	val, err := ef.rt.Read(vAddr, vSize)
	if err != nil {
		ef.log.Error(err)
		return int32(wasm.ResultStatusCode_ResourceNotFound)
	}
	ef.log.WithValues("key", string(key), "val", string(val)).Info("host.SetDB")

	err = ef.kvs.Set(string(key), val)
	if err != nil {
		ef.log.Error(err)
		return int32(wasm.ResultStatusCode_Failed)
	}
	return int32(wasm.ResultStatusCode_OK)
}

func (ef *ExportFuncs) SetSQLDB(addr, size int32) int32 {
	if ef.db == nil {
		return int32(wasm.ResultStatusCode_NoDBContext)
	}
	data, err := ef.rt.Read(addr, size)
	if err != nil {
		ef.log.Error(err)
		return int32(wasm.ResultStatusCode_ResourceNotFound)
	}

	prestate, params, err := sql_util.ParseQuery(data)
	if err != nil {
		ef.log.Error(err)
		return wasm.ResultStatusCode_Failed
	}

	_, err = ef.db.ExecContext(context.Background(), prestate, params...)
	if err != nil {
		ef.log.Error(err)
		return wasm.ResultStatusCode_Failed
	}

	return int32(wasm.ResultStatusCode_OK)
}

func (ef *ExportFuncs) GetSQLDB(addr, size int32, vmAddrPtr, vmSizePtr int32) int32 {
	if ef.db == nil {
		return int32(wasm.ResultStatusCode_NoDBContext)
	}
	data, err := ef.rt.Read(addr, size)
	if err != nil {
		ef.log.Error(err)
		return int32(wasm.ResultStatusCode_ResourceNotFound)
	}

	prestate, params, err := sql_util.ParseQuery(data)
	if err != nil {
		ef.log.Error(err)
		return wasm.ResultStatusCode_Failed
	}

	rows, err := ef.db.QueryContext(context.Background(), prestate, params...)
	if err != nil {
		ef.log.Error(err)
		return wasm.ResultStatusCode_Failed
	}

	ret, err := sql_util.JsonifyRows(rows)
	if err != nil {
		ef.log.Error(err)
		return wasm.ResultStatusCode_Failed
	}

	if err := ef.rt.Copy(ret, vmAddrPtr, vmSizePtr); err != nil {
		ef.log.Error(err)
		return int32(wasm.ResultStatusCode_TransDataToVMFailed)
	}

	return int32(wasm.ResultStatusCode_OK)
}

// TODO: make sendTX async, and add callback if possible
func (ef *ExportFuncs) SendTX(chainID int32, offset, size, vmAddrPtr, vmSizePtr int32) int32 {
	if ef.cl == nil {
		ef.log.Error(errors.New("eth client doesn't exist"))
		return wasm.ResultStatusCode_Failed
	}
	buf, err := ef.rt.Read(offset, size)
	if err != nil {
		ef.log.Error(err)
		return wasm.ResultStatusCode_Failed
	}
	ret := gjson.Parse(string(buf))
	txHash, err := ef.cl.SendTX(uint32(chainID), ret.Get("to").String(), ret.Get("value").String(), ret.Get("data").String())
	if err != nil {
		ef.log.Error(err)
		return wasm.ResultStatusCode_Failed
	}
	if err := ef.rt.Copy([]byte(txHash), vmAddrPtr, vmSizePtr); err != nil {
		ef.log.Error(err)
		return wasm.ResultStatusCode_Failed
	}
	return int32(wasm.ResultStatusCode_OK)
}

func (ef *ExportFuncs) SendMqttMsg(topicAddr, topicSize, msgAddr, msgSize int32) int32 {
	if ef.mq == nil || ef.mq.Client == nil {
		ef.log.Error(errors.New("mq client doesn't exist"))
		return wasm.ResultStatusCode_Failed
	}

	var (
		topicBuf []byte
		msgBuf   []byte
		err      error
	)

	topicBuf, err = ef.rt.Read(topicAddr, topicSize)
	if err != nil {
		ef.log.Error(err)
		return wasm.ResultStatusCode_Failed
	}
	msgBuf, err = ef.rt.Read(msgAddr, msgSize)
	if err != nil {
		ef.log.Error(err)
		return wasm.ResultStatusCode_Failed
	}
	err = ef.mq.WithTopic(string(topicBuf)).Publish(string(msgBuf))
	if err != nil {
		ef.log.Error(err)
		return wasm.ResultStatusCode_Failed
	}
	return int32(wasm.ResultStatusCode_OK)
}

func (ef *ExportFuncs) CallContract(chainID int32, offset, size int32, vmAddrPtr, vmSizePtr int32) int32 {
	if ef.cl == nil {
		ef.log.Error(errors.New("eth client doesn't exist"))
		return wasm.ResultStatusCode_Failed
	}
	buf, err := ef.rt.Read(offset, size)
	if err != nil {
		ef.log.Error(err)
		return wasm.ResultStatusCode_Failed
	}
	ret := gjson.Parse(string(buf))
	data, err := ef.cl.CallContract(uint32(chainID), ret.Get("to").String(), ret.Get("data").String())
	if err != nil {
		ef.log.Error(err)
		return wasm.ResultStatusCode_Failed
	}
	if err = ef.rt.Copy(data, vmAddrPtr, vmSizePtr); err != nil {
		ef.log.Error(err)
		return wasm.ResultStatusCode_Failed
	}
	return int32(wasm.ResultStatusCode_OK)
}

func (ef *ExportFuncs) GetEnv(kAddr, kSize int32, vmAddrPtr, vmSizePtr int32) int32 {
	if ef.env == nil {
		return int32(wasm.ResultStatusCode_EnvKeyNotFound)
	}
	key, err := ef.rt.Read(kAddr, kSize)
	if err != nil {
		return int32(wasm.ResultStatusCode_TransDataToVMFailed)
	}

	val, ok := ef.env.Get(string(key))
	if !ok {
		return int32(wasm.ResultStatusCode_EnvKeyNotFound)
	}

	if err = ef.rt.Copy([]byte(val), vmAddrPtr, vmSizePtr); err != nil {
		ef.log.Error(err)
		return int32(wasm.ResultStatusCode_TransDataToVMFailed)
	}
	return int32(wasm.ResultStatusCode_OK)
}

func (ef *ExportFuncs) GetEventType(rid, vmAddrPtr, vmSizePtr int32) int32 {
	data, ok := ef.res.Load(uint32(rid))
	if !ok {
		return int32(wasm.ResultStatusCode_ResourceNotFound)
	}

	if err := ef.rt.Copy(data, vmAddrPtr, vmSizePtr); err != nil {
		ef.log.Error(err)
		return int32(wasm.ResultStatusCode_TransDataToVMFailed)
	}

	return int32(wasm.ResultStatusCode_OK)
}
